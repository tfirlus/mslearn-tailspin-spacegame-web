# ASP.NET Core
# Build and test ASP.NET Core projects targeting .NET Core.
# Add steps that run tests, create a NuGet package, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core

trigger:
- '*'

# The demands section beneath pool specifies that you need npm, the Node.js package manager, installed on the build system.
pool:
  vmImage: 'ubuntu-20.04'
  demands:
  - npm

variables:
  buildConfiguration: 'Release'
  wwwrootDir: 'Tailspin.SpaceGame.Web/wwwroot'
  dotnetSdkVersion: '6.x'

# Under the steps section, you see the build tasks that maps to each of the script commands that we identified earlier.
#
# Azure Pipelines provides built-in build tasks that map to many common build activities.
# For example, the DotNetCoreCLI@2 task maps to the dotnet command-line utility.
# The pipeline uses DotNetCoreCLI@2 two times: one time to restore, or install, the project's dependencies, and one time to build the project.
#
# Remember that not all build activities map to a built-in task.
# For example, there's no built-in task that runs the node-Sass utility, or writes build info to a text file.
# To run general system commands, you use the CmdLine@2 or script task.
# The pipeline uses the script task because it's a common shortcut for CmdLine@2.

steps:
- task: UseDotNet@2
  displayName: 'Use .NET SDK $(dotnetSdkVersion)'
  inputs:
    packageType: sdk
    version: '$(dotnetSdkVersion)'

# # Install Node.js modules as defined in package.json.
# npm install --quiet
- task: Npm@1                                   # -> npm install
  displayName: 'Run npm install'
  inputs:
    verbose: false

# # Compile Sass (.scss) files to standard CSS (.css).
# node-sass Tailspin.SpaceGame.Web/wwwroot
- script: './node_modules/.bin/node-sass $(wwwrootDir) --output $(wwwrootDir)'
  displayName: 'Compile Sass assets'

# # Minify JavaScript and CSS files.
# gulp
- task: gulp@1                                  # -> gulp
  displayName: 'Run gulp tasks'

# $(Build.DefinitionName) specifies the name of the build pipeline. For example, "SpaceGame-Web-CI."
# $(Build.BuildId) is a numeric identifier for the completed build, like 115.
# $(Build.BuildNumber) is name of the completed build. You can configure the format,
#    but by default the build number includes the current date followed by the build number for that day.
#    An example build number is "20190329.1."

# # Print the date to wwwroot/buildinfo.txt.
# echo `date` > Tailspin.SpaceGame.Web/wwwroot/buildinfo.txt
- script: 'echo "$(Build.DefinitionName), $(Build.BuildId), $(Build.BuildNumber)" > buildinfo.txt'
  displayName: 'Write build info'
  workingDirectory: $(wwwrootDir)

# # Install the latest .NET packages the app depends on.
# dotnet restore
- task: DotNetCoreCLI@2                         # The DotNetCoreCLI@2 task maps to the dotnet command
  displayName: 'Restore project dependencies'       # displayName defines the task name that's shown in the user interface
  inputs:                                           # inputs defines arguments that are passed to the command
    command: 'restore'                                  # command specifies to run the dotnet build subcommand
    projects: '**/*.csproj'                             # projects specifies which projects to build

# # Build (and publish) the app under the Debug configuration.
- template: templates/build.yml
  parameters:
    buildConfiguration: 'Debug'

# # Build (and publish) the app under the Release configuration.
- template: templates/build.yml
  parameters:
    buildConfiguration: 'Release'

- task: PublishBuildArtifacts@1                 # task uses the PublishBuildArtifacts@1 task to publish the .zip file to Azure Pipelines
  displayName: 'Publish Artifact: drop'
  condition: succeeded()                            # The condition argument specifies to run the task only when the previous task succeeds. succeeded() is the default condition, so you don't need to specify it. But we show it here to show its use.
